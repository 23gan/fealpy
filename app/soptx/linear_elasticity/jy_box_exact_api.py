from fealpy.backend import backend_manager as bm

from fealpy.mesh import HexahedronMesh
from fealpy.material.elastic_material import LinearElasticMaterial
from fealpy.fem.linear_elastic_integrator import LinearElasticIntegrator
from fealpy.fem.vector_source_integrator import VectorSourceIntegrator
from fealpy.fem.bilinear_form import BilinearForm
from fealpy.fem.linear_form import LinearForm
from fealpy.fem.dirichlet_bc import DirichletBC
from fealpy.functionspace import LagrangeFESpace, TensorFunctionSpace
from fealpy.typing import TensorLike
from fealpy.decorator import cartesian
from fealpy.sparse import COOTensor
from fealpy.solver import cg, spsolve

from app.gearx.utils import *

def export_to_inp_abaqus(filename, nodes, elements, fixed_nodes, load_nodes, loads, young_modulus, poisson_ratio, density):
    """
    齿轮专用的，相关信息导出为 Abaqus 的 inp 文件
    :param filename: 文件名
    :param nodes: 网格节点
    :param elements: 网格单元 (注: 网格节点从0开始编号, 导出时需要+1以符合Abaqus的编号规则)
    :param fixed_nodes: 固定点索引
    :param load_nodes: 载荷点索引
    :param loads: 载荷点载荷
    :param young_modulus: 杨氏模量
    :param poisson_ratio: 泊松比 
    :param density: 密度
    :return:
    """
    with open(filename, 'w') as file:
        file.write("*Heading\n** Generated by Custom Export Script\n*Preprint, echo=NO, model=NO, history=NO, contact=NO\n")
        file.write("*Part, name=Gear\n")
        file.write("*Node\n")

        # 写入节点信息
        for i, node in enumerate(nodes):
            file.write(f"{i+1}, {node[0]}, {node[1]}, {node[2]}\n")

        # 写入单元信息
        file.write("*Element, type=C3D8, elset=AllElements\n")
        for i, elem in enumerate(elements):
            # 在写入时进行+1操作
            elem_str = ", ".join(str(e + 1) for e in elem)
            file.write(f"{i+1}, {elem_str}\n")

        # 写入截面
        file.write("*Solid Section, elset=AllElements, material=Steel\n")
        file.write("*End Part\n**\n")

        # 定义装配和实例
        file.write("*Assembly, name=Assembly\n*Instance, name=GearInstance, part=Gear\n*End Instance\n")

        # 定义固定节点集
        file.write("*Nset, nset=FixedNodes, instance=GearInstance\n")
        for i in range(0, len(fixed_nodes), 16):
            nodes_str = ", ".join(str(node + 1) for node in fixed_nodes[i:i + 16])
            file.write(f"{nodes_str},\n")


        # 定义载荷节点集
        file.write("*Nset, nset=LoadNodes, instance=GearInstance\n")
        for i in range(0, len(load_nodes), 16):
            nodes_str = ", ".join(str(node + 1) for node in load_nodes[i:i + 16])
            file.write(f"{nodes_str},\n")
        file.write("*End Assembly\n")

        # 写入材料信息
        file.write("*Material, name=Steel\n")
        file.write(f"*Density\n{density}\n")
        file.write(f"*Elastic\n{young_modulus}, {poisson_ratio}\n")

        # 写入步骤、边界条件和载荷
        file.write("** STEP: LoadStep\n*Step, name=LoadStep, nlgeom=NO\n*Static\n1., 1., 1e-05, 1.\n")

        # 固定边界条件
        file.write("*Boundary\nFixedNodes, ENCASTRE\n")

        # 施加集中载荷
        file.write(f"*Cload\n")
        for i, load_node in enumerate(load_nodes):
            node_id = load_node + 1  # 在使用时进行+1操作
            forces = loads[i]
            file.write(f"GearInstance.{node_id}, 1, {forces[0]}\n")
            file.write(f"GearInstance.{node_id}, 2, {forces[1]}\n")
            file.write(f"GearInstance.{node_id}, 3, {forces[2]}\n")

        file.write("*Output, field, variable=PRESELECT\n")
        file.write("*Output, history, variable=PRESELECT\n")
        file.write("*End Step\n")
        file.write("** Output Global Stiffness Matrix\n")
        file.write("*Step, name=Global_Stiffness_Matrix\n")
        file.write("*MATRIX GENERATE, STIFFNESS, element by element\n")
        file.write("*MATRIX OUTPUT, STIFFNESS, FORMAT=COORDINATE\n")
        file.write("*End Step\n")

class BoxDomainPolyLoaded3d():
    def __init__(self):
        """
        flip_direction = True
        0 ------- 3 ------- 6 
        |    0    |    2    |
        1 ------- 4 ------- 7 
        |    1    |    3    |
        2 ------- 5 ------- 8 
        """
        self.eps = 1e-12

    def domain(self):
        return [0, 1, 0, 1, 0, 1]

    @cartesian
    def source(self, points: TensorLike):
        x = points[..., 0]
        y = points[..., 1]
        z = points[..., 2]
        val = bm.zeros(points.shape, 
                       dtype=points.dtype, device=bm.get_device(points))
        mu = 1
        factor1 = -400 * mu * (2 * y - 1) * (2 * z - 1)
        term1 = 3 * (x ** 2 - x) ** 2 * (y ** 2 - y + z ** 2 - z)
        term2 = (1 - 6 * x + 6 * x ** 2) * (y ** 2 - y) * (z ** 2 - z)
        val[..., 0] = factor1 * (term1 + term2)

        factor2 = 200 * mu * (2 * x - 1) * (2 * z - 1)
        term1 = 3 * (y ** 2 - y) ** 2 * (x ** 2 - x + z ** 2 - z)
        term2 = (1 - 6 * y + 6 * y ** 2) * (x ** 2 - x) * (z ** 2 - z)
        val[..., 1] = factor2 * (term1 + term2)

        factor3 = 200 * mu * (2 * x - 1) * (2 * y - 1)
        term1 = 3 * (z ** 2 - z) ** 2 * (x ** 2 - x + y ** 2 - y)
        term2 = (1 - 6 * z + 6 * z ** 2) * (x ** 2 - x) * (y ** 2 - y)
        val[..., 2] = factor3 * (term1 + term2)

        return val

    @cartesian
    def solution(self, points: TensorLike):
        x = points[..., 0]
        y = points[..., 1]
        z = points[..., 2]
        val = bm.zeros(points.shape, 
                       dtype=points.dtype, device=bm.get_device(points))

        mu = 1
        val[..., 0] = 200*mu*(x-x**2)**2 * (2*y**3-3*y**2+y) * (2*z**3-3*z**2+z)
        val[..., 1] = -100*mu*(y-y**2)**2 * (2*x**3-3*x**2+x) * (2*z**3-3*z**2+z)
        val[..., 2] = -100*mu*(z-z**2)**2 * (2*y**3-3*y**2+y) * (2*x**3-3*x**2+x)

        return val

    def dirichlet(self, points: TensorLike) -> TensorLike:

        result = bm.zeros(points.shape, 
                        dtype=points.dtype, device=bm.get_device(points))

        return result
    
bm.set_backend('numpy')

def compute_equivalent_strain(strain, nu):
    exx = strain[..., 0, 0]
    eyy = strain[..., 1, 1]
    ezz = strain[..., 2, 2]
    gamma_xy = strain[..., 0, 1]
    gamma_yz = strain[..., 1, 2]
    gamma_xz = strain[..., 0, 2]
    
    d1 = exx - eyy
    d2 = eyy - ezz
    d3 = ezz - exx
    
    equiv_strain = (d1**2 + d2**2 + d3**2 + 6.0 * (gamma_xy**2 + gamma_yz**2 + gamma_xz**2))
    
    # equiv_strain = bm.sqrt(equiv_strain / 2.0) / (1.0 + nu)
    equiv_strain = bm.sqrt(equiv_strain / 2.0) / (1.0)
    
    return equiv_strain

def compute_equivalent_stress(stress, nu):
    sxx = stress[..., 0, 0]
    syy = stress[..., 1, 1]
    szz = stress[..., 2, 2]
    sxy = stress[..., 0, 1]
    syz = stress[..., 1, 2]
    sxz = stress[..., 0, 2]
    
    d1 = sxx - syy
    d2 = syy - szz
    d3 = szz - sxx
    
    equiv_stress = (d1**2 + d2**2 + d3**2 + 6.0 * (sxy**2 + syz**2 + sxz**2))

    equiv_stress = bm.sqrt(equiv_stress / 2.0)
    
    return equiv_stress

nx, ny, nz = 4, 4, 4 
mesh = HexahedronMesh.from_box(box=[0, 1, 0, 1, 0, 1], 
                            nx=nx, ny=ny, nz=nz, device=bm.get_device('cpu'))
GD = mesh.geo_dimension()
NN = mesh.number_of_nodes()
NC = mesh.number_of_cells()
print(f"NN = {NN} NC = {NC}")
cm = mesh.cell_volume()
node = mesh.entity('node')
cell = mesh.entity('cell')

p = 1
q = p+1
space = LagrangeFESpace(mesh, p=p, ctype='C')
sgdof = space.number_of_global_dofs()
print(f"sgdof: {sgdof}")
tensor_space = TensorFunctionSpace(space, shape=(3, -1)) # dof_priority
tgdof = tensor_space.number_of_global_dofs()
print(f"tgdof: {tgdof}")

# 刚度矩阵
E = 206e3
nu = 0.3
lam = (E * nu) / ((1.0 + nu) * (1.0 - 2.0 * nu))
mu = E / (2.0 * (1.0 + nu))
linear_elastic_material = LinearElasticMaterial(name='E_nu',
                                                elastic_modulus=E, poisson_ratio=nu, 
                                                hypo='3D', device=bm.get_device(mesh))
integrator_K = LinearElasticIntegrator(material=linear_elastic_material, q=q)
bform = BilinearForm(tensor_space)
bform.add_integrator(integrator_K)
K = bform.assembly(format='csr')
values = K.values()
K_norm = bm.sqrt(bm.sum(values * values))
print(f"K.shape = {K.shape}")
print(f"Matrix norm before dc: {K_norm:.6f}")

# 载荷向量
pde = BoxDomainPolyLoaded3d()
integrator_F = VectorSourceIntegrator(source=pde.source, q=q)
lform = LinearForm(tensor_space)    
lform.add_integrator(integrator_F)
F = lform.assembly()
F_norm = bm.sqrt(bm.sum(F * F))   
print(f"F.shape = {F.shape}")
print(f"Load vector norm before dc: {F_norm:.6f}")

# 导入 inp 文件
if tensor_space.dof_priority == True:
    F_load_nodes = bm.transpose(F.reshape(GD, NN))
else:
    F_load_nodes = F.reshape(NN, GD)
non_zero_loads = bm.linalg.norm(F_load_nodes, axis=1) > 1e-12
load_node_indices = bm.arange(NN)[non_zero_loads]  
F_load_nodes = F_load_nodes[non_zero_loads]  
print(f"F_load_nodes.shape = {F_load_nodes.shape}:\n {F_load_nodes}, ")
isBdDof = tensor_space.is_boundary_dof(threshold=None)
fixed_node_index = bm.where(isBdDof)[0]
export_to_inp_abaqus(filename='/home/heliang/FEALPy_Development/fealpy/app/soptx/linear_elasticity/box_fealpy.inp', 
              nodes=node, elements=cell, 
              fixed_nodes=fixed_node_index, load_nodes=load_node_indices, loads=F_load_nodes, 
              young_modulus=206e3, poisson_ratio=0.3, density=7.85e-9)

# 边界条件处理
dbc = DirichletBC(space=tensor_space, 
                gd=pde.dirichlet, 
                threshold=None, 
                method='interp')
K = dbc.apply_matrix(matrix=K, check=True)
uh_bd = bm.zeros(tensor_space.number_of_global_dofs(), 
                dtype=bm.float64, device=bm.get_device(mesh))
uh_bd, isDDof = tensor_space.boundary_interpolate(gd=pde.dirichlet, 
                                                uh=uh_bd, threshold=None, method='interp')
F = F - K.matmul(uh_bd)
F = bm.set_at(F, isDDof, uh_bd[isDDof])

# 求解
uh = tensor_space.function()
uh[:] = cg(K, F, maxiter=1000, atol=1e-8, rtol=1e-8)

# 后处理
if tensor_space.dof_priority:
    uh_show = uh.reshape(GD, NN).T
else:
    uh_show = uh.reshape(NN, GD)
uh_magnitude = bm.linalg.norm(uh_show, axis=1)
mesh.nodedata['uh'] = uh_show[:]
mesh.nodedata['uh_magnitude'] = uh_magnitude[:]
mesh.to_vtk('/home/heliang/FEALPy_Development/fealpy/app/soptx/linear_elasticity/gear_box_fealpy.vtu')


# 验证收敛阶
maxit = 4
errorType = ['$|| u  - u_h ||_{L2}$', '$|| u -  u_h||_{l2}$']
errorMatrix = bm.zeros((len(errorType), maxit), dtype=bm.float64)
NDof = bm.zeros(maxit, dtype=bm.int32)
for i in range(maxit):
    space = LagrangeFESpace(mesh, p=p, ctype='C')
    tensor_space = TensorFunctionSpace(space, shape=(3, -1)) # dof_priority

    NDof[i] = tensor_space.number_of_global_dofs()

    # linear_elastic_material = LinearElasticMaterial(name='E_nu',
    #                                             elastic_modulus=E, poisson_ratio=nu, 
    #                                             hypo='3D', device=bm.get_device(mesh))
    linear_elastic_material = LinearElasticMaterial(name='lam1_mu1', 
                                                lame_lambda=1, shear_modulus=1, 
                                                hypo='3D', device=bm.get_device(mesh))

    integrator_K = LinearElasticIntegrator(material=linear_elastic_material, q=q)
    bform = BilinearForm(tensor_space)
    bform.add_integrator(integrator_K)
    K = bform.assembly(format='csr')

    integrator_F = VectorSourceIntegrator(source=pde.source, q=q)
    lform = LinearForm(tensor_space)    
    lform.add_integrator(integrator_F)
    F = lform.assembly()

    dbc = DirichletBC(space=tensor_space, 
                    gd=pde.dirichlet, 
                    threshold=None, 
                    method='interp')
    K = dbc.apply_matrix(matrix=K, check=True)
    uh_bd = bm.zeros(tensor_space.number_of_global_dofs(), 
                    dtype=bm.float64, device=bm.get_device(mesh))
    uh_bd, isDDof = tensor_space.boundary_interpolate(gd=pde.dirichlet, 
                                                    uh=uh_bd, threshold=None, method='interp')
    F = F - K.matmul(uh_bd)
    F = bm.set_at(F, isDDof, uh_bd[isDDof])

    uh = tensor_space.function()
    uh[:] = cg(K, F, maxiter=1000, atol=1e-8, rtol=1e-8)
    # uh[:] = spsolve(K, F, solver="mumps")

    u_exact = tensor_space.interpolate(pde.solution)
    errorMatrix[0, i] = bm.sqrt(bm.sum(bm.abs(uh[:] - u_exact)**2 * (1 / NDof[i])))
    errorMatrix[1, i] = mesh.error(u=uh, v=pde.solution, q=tensor_space.p+3, power=2)

    if i < maxit-1:
        mesh.uniform_refine()

print("errorMatrix:\n", errorType, "\n", errorMatrix)
print("NDof:", NDof)
print("order_l2:\n", bm.log2(errorMatrix[0, :-1] / errorMatrix[0, 1:]))
print("order_L2:\n ", bm.log2(errorMatrix[1, :-1] / errorMatrix[1, 1:]))
print("----------------------")

